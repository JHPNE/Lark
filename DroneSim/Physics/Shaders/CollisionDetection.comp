#version 430

layout(local_size_x = 256) in;

// Define the BVHNode struct outside the buffer block
struct BVHNode {
    vec4 boundsMin;
    vec4 boundsMax;
    uint leftChild;
    uint rightChild;
    uint parent;
    uint isLeaf;
};

// Inputs: BVH Nodes and sorted indices
layout(std430, binding = 3) buffer BVHNodesBuffer {
    BVHNode nodes[];
};
layout(std430, binding = 1) buffer Indices {
    uint sortedIndices[];
};

// Output: Collision Pairs
layout(std430, binding = 2) buffer CollisionPairsBuffer {
    uvec2 collisionPairs[]; // Use uvec2 instead of uint2
};

// Atomic counter for collision pairs
layout(binding = 6, offset = 0) uniform atomic_uint collisionCount;

uniform uint NUM_OBJECTS;
uniform float dt;

// Function to check AABB overlap
bool aabbOverlap(vec4 minA, vec4 maxA, vec4 minB, vec4 maxB) {
    return (minA.x <= maxB.x && maxA.x >= minB.x) &&
    (minA.y <= maxB.y && maxA.y >= minB.y) &&
    (minA.z <= maxB.z && maxA.z >= minB.z);
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= NUM_OBJECTS) return;

    uint indexA = sortedIndices[gid];
    BVHNode nodeA = nodes[indexA];

    // Traverse BVH to find potential overlaps
    for (uint i = gid + 1; i < NUM_OBJECTS; i++) {
        uint indexB = sortedIndices[i];
        BVHNode nodeB = nodes[indexB];

        if (aabbOverlap(nodeA.boundsMin, nodeA.boundsMax, nodeB.boundsMin, nodeB.boundsMax)) {
            // Record the collision pair
            uint pairIndex = atomicCounterIncrement(collisionCount);
            collisionPairs[pairIndex] = uvec2(indexA, indexB); // Use uvec2 here
        }
    }
}
