#version 430

layout(local_size_x = 256) in;

// Positions
layout(std430, binding = 0) buffer PositionBuffer {
    vec4 positions[];
};

// Output: Morton codes
layout(std430, binding = 2) buffer MortonCodesBuffer {
    uint mortonCodes[];
};

// Optional: If you compute bounds
// layout(std430, binding = 1) buffer BoundsBuffer {
//     vec4 boundsMin[];
//     vec4 boundsMax[];
// };

uniform uint NUM_OBJECTS;
uniform vec3 sceneMin;
uniform vec3 sceneMax;

// Morton encoding helper function
uint expandBits(uint v) {
    v = (v * 0x00010001u) & 0xFF0000FFu;
    v = (v * 0x00000101u) & 0x0F00F00Fu;
    v = (v * 0x00000011u) & 0xC30C30C3u;
    v = (v * 0x00000005u) & 0x49249249u;
    return v;
}

uint morton3D(float x, float y, float z) {
    x = clamp((x - sceneMin.x) / (sceneMax.x - sceneMin.x), 0.0, 1.0);
    y = clamp((y - sceneMin.y) / (sceneMax.y - sceneMin.y), 0.0, 1.0);
    z = clamp((z - sceneMin.z) / (sceneMax.z - sceneMin.z), 0.0, 1.0);

    uint xx = expandBits(uint(x * 1023.0));
    uint yy = expandBits(uint(y * 1023.0));
    uint zz = expandBits(uint(z * 1023.0));
    return (xx << 2) + (yy << 1) + zz;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= NUM_OBJECTS) return;

    vec3 centroid2 = positions[i].xyz;
    mortonCodes[i] = morton3D(centroid2.x, centroid2.y, centroid2.z);
}
