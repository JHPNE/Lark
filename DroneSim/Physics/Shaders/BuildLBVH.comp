#version 430

layout(local_size_x = 256) in;

// Define the BVHNode struct outside the buffer block
struct BVHNode {
    vec4 boundsMin;
    vec4 boundsMax;
    uint leftChild;
    uint rightChild;
    uint parent;
    uint isLeaf;
};

// Inputs
layout(std430, binding = 0) buffer MortonCodes {
    uint mortonCodes[];
};
layout(std430, binding = 1) buffer Indices {
    uint indices[];
};
layout(std430, binding = 2) buffer PositionBuffer {
    vec4 positions[];
};

// Output: BVH Nodes
layout(std430, binding = 3) buffer BVHNodesBuffer {
    BVHNode nodes[];
};

uniform uint NUM_OBJECTS;

// Helper function to find the common prefix length
uint commonPrefix(uint a, uint b) {
    if (a == b) return 32;
    uint x = a ^ b;
    uint leadingZeros = 0;
    for (int i = 31; i >= 0; i--) {
        if ((x & (1u << i)) != 0u) {
            leadingZeros = 32u - uint(i);
            break;
        }
    }
    return leadingZeros;
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= NUM_OBJECTS - 1) return;

    uint codeA = mortonCodes[i];
    uint codeB = mortonCodes[i + 1];
    uint lcp = commonPrefix(codeA, codeB);

    // Find the split point using binary search
    int left = int(i) + 1;
    int right = int(NUM_OBJECTS);

    while (left < right) {
        int mid = left + (right - left) / 2;
        uint midCode = mortonCodes[mid];
        uint midLcp = commonPrefix(codeA, midCode);
        if (midLcp > lcp) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    int split = left;

    // Assign children
    uint nodeIndex = i; // Simple indexing; adjust as needed
    BVHNode node;
    node.isLeaf = 0;
    node.parent = 0; // To be set in a separate pass

    if (split == int(i + 1)) {
        // Leaf node
        node.leftChild = indices[i];
        node.rightChild = indices[i + 1];
    } else {
        // Internal nodes
        node.leftChild = uint(NUM_OBJECTS - 1 + i); // Example indexing
        node.rightChild = uint(NUM_OBJECTS - 1 + split);
    }

    // Compute bounds by merging child bounds
    vec3 childMin1 = positions[node.leftChild].xyz;
    vec3 childMax1 = positions[node.leftChild].xyz; // Assuming points; replace with actual bounds
    vec3 childMin2 = positions[node.rightChild].xyz;
    vec3 childMax2 = positions[node.rightChild].xyz;

    node.boundsMin = vec4(min(childMin1, childMin2), 1.0);
    node.boundsMax = vec4(max(childMax1, childMax2), 1.0);

    nodes[nodeIndex] = node;
}
